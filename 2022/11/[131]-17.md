## 목차
[1. K8s](#k8s)   

## K8s
# Kubernetes

## 컨테이너 오케스트레이션

가상 머신의 문제는 클라우드 환경과 안 맞고 느리다는 단점이 있다.

이때, 도커가 나와서 실행 환경을 컨테이너로 바꾸게 되었다.

### 1. 컨테이너 특징

- 가상머신 보다 생성이 쉽고 효율적이다.
- 이미지 배포와 롤백이 간단하다.
- 언어, 프레임워크에 상관 없이 동일한 방식으로 관리한다.
- 개발, 테스팅, 운영 모두 동일 환경을 구축해 준다.
- 오픈 소스이고 특정 클라우드 벤더(aws..)에 종속적이지 않는다.

### 2. 과정

코드 작성 → 빌드 → 도커 허브 등 저장소 저장 → 실행

developer → build → ship → run!

위와 같은 과정으로 서버 관리가 압축이 되었다.

### 3. 컨테이너 부하

컨테이너가 많으면 부하가 생길 수 있고 컨테이너가 너무 많아지면 관리가 어려워진다.

**[배포]**
만약, 3가지 컨테이너를 배포하기 위해서 각 서버에 접속을 해서 하나하나 배포를 해 줘야 한다. 또, 어떤 서버에 공간이 있는지 알 수 없다.

**[서비스 검색]**
프록시가 하나의 컨테이너를 바라보고 있을 때 컨테이너가 한 대 추가되면 로드밸런서를 갈아껴야 한다. IP가 바뀌거나 서비스가 추가될 때 마다 로드밸런서를 갈아끼는 게 상당히 번거롭다.

밖에 호스트를 두고 호스트를 통해 값이 들오고 쪼개서 요청을 나눠주는 방법도 있지만 자동으로 설정을 해 주진 못 한다.

**[부하]**
여러 컨테이너를 운영하다 다른 컨테이너가 죽어버리면 에러가 모두 나서 해결해야 한다. 또, 부하를 받게 되면 응답 속도가 느려져서 서버를 늘려야 하는데 역시 자동으로 되진 않는다.

### 4. 컨테이너 오케스트레이션

서버 관리자가 하던 일들을 컨테이너 오케스트레이션이 대신 해준다.

**[클러스터]**
어떤 노드에 뭐가 있고, 어떤 노드에 뭐가 있다. 이런 관리가 아니라 클러스터 단위로 관리를 하게 된다. 명령을 보내면 마스터 노드를 통해 알아서 명령 전달이 되게 된다.

**[노드 스케일]**
부하가 생겼을 때 부하를 감당할 수 있어야 하낟.

**[상태 관리]**
레플리카셋을 통해 컨테이너의 갯수를 간단하게 조절해 상태를 맞춰 줄 수 있다. 이때 셋 중 하나가 문제가 생기면 문제가 생긴 서버를 죽이고 새로 서버를 만드는 것도 가능해 진다.

**[스케줄링]**
어떤 서버에 뭐가 떠있고 여유가 있는 지 알아야 하는데 이걸 자동으로 해 주게 된다.

**[버전 관리]**
버전 1이 떠있는데 버전 2로 배포했다. 이때 롤백이 필요하게 되면 하나하나 관리하는 게 아니라 중앙에서 전체적으로 관리하게 된다.

**[볼륨 스토리지]**
각 서버마다 스토리지를 연결해야 할 필요가 있을 수도 있는데 간단하게 관리할 수 있다.

결과적으로 컨테이너 오케스트레이션 자체는 개념이다. 때문에 어떻게 잘 구현하느냐가 중요하게 생각된다.

쿠버네티스, 도커 스웜 등 많은 컨테이너 관리 도구가 생기게 되었지만 지금은 쿠버네티스가 많이 사용된다.